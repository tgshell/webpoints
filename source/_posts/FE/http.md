title: http
date: 2020-12-23 10:20:00
categories: 
- fe
tags:
- http1.0
- http1.1
- http2.0
- websocket
---

## http

### http1.0、http1.1、http2.0、http3.0

#### http1.0

浏览器的每次请求都需要与服务器建立一个 TCP 连接，下一个请求必须在前一个请求响应到达之前才能发送

无状态：服务器不跟踪每个客户端也不记录过去的请求
无连接：服务器处理完成后立即断开 TCP 连接，无法复用连接

#### http1.1

- 浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞，所以一些站点的资源会使用多个 CDN 域名来突破数量限制
- 并发依赖于多个 TCP 连接

特性：

长连接：HTTP1.1 增加了一个 Connection 字段，通过设置 Keep-Alive 可以保持 HTTP 连接不断开，避免了每次客户端与服务器请求都要重复建立释放建立 TCP 连接，提高了网络的利用率。如果客户端想关闭 HTTP 连接，可以在请求头中携带 Connection: false 来告知服务器关闭请求

缓存处理：在 HTTP1.0 中主要使用 header 里的 If-Modified-Since, Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。

带宽优化及网络连接的使用：HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
错误通知的管理，在 HTTP1.1 中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

Host 头处理：在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。

#### http2.0

二进制分帧：通过在应用层和传输层之间增加一个二进制分帧层，将所有传输的信息进行二进制格式的编码，分割为更小的消息和帧

多路复用：基于二进制分帧，在**同一域名**下所有访问都是从同一个 tcp 连接中走，真正的并行传输，在一个 TCP 上进行任意数量双向数据流
- 流（stream）：已建立连接上的双向字节流
- 消息：与逻辑消息对应的完整的一系列数据帧
- 帧（frame）：HTTP2.0 通信的最小单位，每个帧包含帧头部，至少也会标识出当前帧所属的流（stream id）
每个请求是一个数据流，数据流以消息的方式发送，而消息又分为多个帧，帧头部记录着 stream id 用来标识所属的数据流，不同属的帧可以在连接中随机混杂在一起。接收方可以根据 stream id 将帧再归属到各自不同的请求当中去

头部压缩：减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，避免重复的 header 传输，减少传输内容大小

服务器推送：服务器可以主动向客户端推送资源

#### 区别

- http1.0 到http1.1的主要区别，就是从无连接到长连接
- http2.0对比1.X版本主要区别就是多路复用

#### 参考

[HTTP1.0 HTTP1.1 HTTP2.0 主要特性对比](https://segmentfault.com/a/1190000013028798)

### http 缓存

[彻底弄懂HTTP缓存机制及原理](https://www.cnblogs.com/chenqf/p/6386163.html)

## websocket

## http、websocket 适用场景

相比较 WebSocket 和 HTTP，可以说 HTTP 请求比 WebSocket 更简单，但是也有局限性。在不同的使用场景可以选择更合适的协议。目前互联网上大多数网站都是直接加载网页，除了单击加载新页面之外，交互工作都很少。在这种场景下没有必要保持长连接，使用 WebSocket 会显得过于“笨重”。一般的网页都会使用静态资源，例如 Image 图片，Javascript 或 CSS 文件等。为了加载更快，这些静态资源都需要进行缓存，而且它们可能并不来自同一个域名，这时当然使用 HTTP 更为轻便快捷。HTTP 协议的每个请求都需要发送一次请求头，而 WebSocket 仅在初始请求建立连接中携带头信息（当然了，传递消息中也会有一些开销，但都是比较小的）。因此，如果想持续发送多个消息，使用 Websocket 会更节省资源。如果要开发一个客户端和服务器持续交互的程序，那么 WebSockets 将是最佳选择。
